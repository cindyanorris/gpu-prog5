1) Consider the very simple case of 5 blocks and 4 threads per 
block.  Suppose the size of the vector is 1000.
In answering these questions, you do not need to list every index, 
but list enough so that it is clear what the missing indices are. 
Be sure to give both the smallest index and the largest index. 

a. Using block partitioning, what are the indices of the elements
in the vector that are operated on by thread 0 in block 0?

b. Using block partitioning, what are the indices of the elements
in the vector that are operated on by thread 1 in block 0?

c. Using block partitioning, what are the indices of the elements
in the vector that are operated on by thread 0 in block 1?

d. Using cyclic partitioning, what are the indices of the elements
in the vector that are operated on by thread 0 in block 0?

e. Using cyclic partitioning, what are the indices of the elements
in the vector that are operated on by thread 1 in block 0?

f. Using cyclic partitioning, what are the indices of the elements
in the vector that are operated on by thread 0 in block 1?

2) Give the output of running your program like this:
./vecScalarMult 81920000

3) Give the output of running your program like this:
./vecScalarMult 81920001

4) Run some more experiments using large enough vector sizes so that 
the GPU performs better than the CPU.  Which kernel results in 
better performance, the one using cyclic partitioning or the one 
using block partitioning?

5) Why does one kernel provide better performance than the other?


